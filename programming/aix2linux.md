# 系统差异

## 编译相关

### 关于参数`-bkeepfile`
默认情况下，AIX下链接过程中ld会执行垃圾清理，删除没有被引用的全局变量。若需要将一个.o中定义的未被引用的全局变量链接到可执行文件或 .so中，需要在编译的时候加参数 -bkeepfile:modulename.o，这样modulename.o文件上不会执行垃圾清理从而其中定义的全局变量被保留到输出文件中。在Linux不需要加参数。

### 关于动态库的生成与链接
AIX下生成动态库和链接动态库都必须指定参数`-brtl`
Linux下生成动态库时需要使用参数 -shared -fPIC，链接时不需要指定参数。若同一个库文件系统中同时存在动态库和静态库，gcc会优先选用动态库。需要混用动态库和静态库时，需要使用参数 -Wl,-Bstatic与-Wl,-Bdynamic指定，例如：
gcc -o hello hello. c -Wl,-Bstatic -lbar -Wl,-Bdynamic -lfoo
-Wl是告诉gcc将后面的参数传给链接器ld，如果直接调用ld的话不需要-Wl 。

### 关于编译过程中对未定义符号的处理
在默认的情况下AIX与Linux在编译共享库时不检查未定义的函数和全局变量。这在有些情况下在编译阶段会隐藏问题，运行调试时才暴露。为了将问题尽可能在编译阶段暴露出来，可以在编译的时候加上参数，使得在编译时就检查是否有函数未定义。
AIX下的参数  -bernotok  Linux下使用参数 –Wl,--no-undefined （说明 –b 与 –Wl, 说明参数是给连接器的，如果直接调用ld而不是cc，则不用使用-b或 –Wl,）

### 关于Makefile
在Make过程中,进入子目录make, 是否检查命令的退出状态
  make –f makefile || exit 1;

## 信号处理机制
使用signal安装的信号处理函数，AIX下在信号处理过程中遇到新的同样信号会进行处理；Linux下会先屏蔽信号，加入等待队列中（不可靠信号不支持排队，重复的信号会丢失）；信号处理完毕后，恢复信号响应。
在信号处理函数中若longjmp了，信号屏蔽可能无法恢复。从而导致该信号一直block。
解决方法：
1.	使用sigaction安装信号，使用sa.sa_flags = SA_RESTART | SA_NOMASK
或者
2.	使用sigsetjmp、siglongjmp

## 常用的库
A)	iconv库
Linux下libc里已经包含了libiconv库中函数的定义，编译参数里不需要（不能）指定-liconv
相关头文件：/usr/include/iconv.h
AIX需要链接时显式的指定参数-liconv链接iconv库
B)	pthreads与 pthread
AIX pthreads
Linux pthread

## 链接时库顺序
AIX下链接时对库在参数中出现的顺序没有要求。 Linux下，gcc链接时默认每个库会被按出现的顺序搜索一次，如果一个库中的函数被之后出现的库所需要，gcc不会解析该函数；因此链接时被依赖的库要放在列表的最后，否则会报符号未定义。这种情况需要在编译参数中调整库的顺序。若无法通过调整库的顺序解决，若是应用的库最好检查是否是库设计不够合理产生了交叉调用从而进行调整；若是第三方库，可以将相关的库在编译时重复加入到参数，或者使用ld的参数解决。
ld参数 -( archives -) 或 --start-group archives --end-group 可以使库被重复处理。其中archives 是指需要被重复处理的库的列表，可以是文件名，也可以是-l选项。
在使用中，若是使用gcc调用需要在参数前加 -Wl 或 -Xlinker，例如
gcc -Xlinker --start-group  liba.a libb.a -lpublic Xlinker --endgoup 或
gcc -Wl,-( liba.a libb.a -lpublic -Wl,-)
gcc的手册中建议只有在不可避免时使用该参数。

## 字节存储顺序
AIX是big endian，即高字节在低地址，低字节在高地址；Linux是little endian的，即高字节在高地址，低字节在低地址。直接写入多字节的数据（例如int）不能在两个平台之间交换。这一点尤其在系统中有自定的协议时需要注意是否有用到多字节的类型。
容易有问题的调用 fread fwrite send recv；union中使用整数与字符串等相关方法。

## 系统API
A) 数据类型
     系统调用select 函数的参数类型， AIX下fd_set被定义为 typedef  struct fd_set {...} fd_set; 因此其使用 struct fd_set 或者 fd_set 来定义变量都是合法的； gcc 下， fd_set的定义是struct {...} fd_set; 因此其只能使用 fd_set 而不能用struct fd_set的方式定义变量。
     系统调用msgsnd函数 AIX下有定义msgbuf 类型，gcc中默认情况下没有包含其定义，需要编译时加参数-D_GNU_SOURCE。

# 编译不兼容

## 全局变量/函数重复定义
现象及形成的原因
代码中有一些全局变量在头文件（以下简称.h文件）中定义，两个源文件（以下简称.c文件）都include了该头文件；若两个.c编译成的目标文件（以下简称.o文件） 要链接到一个动态库（以下简称.so文件）中，ld报错全局变量重复定义。
此外，在BEICS中，由于设计和结构等原因（例如，BEICS会在某些文件的函数中加入横切点，而这样的函数是不能在批量里调用的），开发人员为了开发的简便，将同样的函数在不同的.c文件中定义了（同名的函数）；若这样的两个.c编译的.o 要链接到一个.so中，ld报错同样会报重复定义。
BEICS移植采用的方案
系统中有同名的全局变量和函数（非static的）是不规范的，需要进行重构。对于全局变量，BEICS迁移所采用的方法是将所有的全局变量从.h文件中剥离到单独的.c文件中，在头文件中定义成外部变量（extern），在需要的地方链接新的.c文件。 对于函数，梳理重名的函数，若系重复定义进行删除；否则进行重新命名。同时要形成规范：头文件中对变量、函数只声明不定义。
参考：
gcc在编译时加参数 -Xlinker -zmuldefs，在链接阶段将忽略重复定义的全局变量和函数。 -Xlinker -zmuldefs是将参数 -zmuldefs传给ld（即 -Wl,-zmuldefs）使其忽略重复定义的全局变量和函数。尽管如此，不推荐使用。重复定义容易带来问题，链接器使用的是不是开发人员想用的函数，一个函数覆盖另外一个函数等等，给开发和调试带来很多麻烦。
关于gcc（ld）总结
一个全局变量或函数在多个.c源文件中定义，并且这些.c编译出的.o文件被链接到同一个动态库.so 或一个可执行文件中时，ld会报错重复定义。
如果这些.o被ar到一个静态库中，不会报错，并且在之后链接该静态库也不会报错。
如果这些.o被ar到两个不同的静态库中，在之后编译可执行程序时两个静态库都被使用，则ld报错重复定义。
如果一个全局变量或函数在多个.so中定义，ld不报错，以第一个为准。
ld  为.so的时候，允许有未定义的符号，在ld为可执行文件的时候，不能有未定义的符号。
ld会将-l指定的动态库作为依赖，而不管是否用到其中的定义。
此外，还需要注意头文件的include顺序，以免系统中存在同名头文件时发生未预期的现象。
 #include “” 形式，首先是c文件所在路径，然后-I定义的顺序，如果-I是系统include目录该项会被忽略（从而保证系统include目录位于最后），最后是系统include目录。 #include <> 不搜索c文件所在路径。

## typedef重复定义
现象
在Linux下编译BEICS代码时发现，报错RESULT 重复定义。原因是在同一个头文件里，重复typedef了RESULT。
解决方案是删除后出现的重复的定义。
AIX下，对一个名字typedef重复，若类型一致则不会报错；否则也是会编译报错的。例如
typedef int RESULT;
.....
typedef int RESULT; 不会报错；而若第二句为 typedef double RESULT 同样会报错。
备注： gcc 4.6以上版本与AIX类似，若重复同样的定义也不会报错。

## 调用时实参和函数声明形参个数不一致
AIX下，调用函数时传给函数的实参数量与函数定义时的形参数可以不一样；Linux下调用函数时实参与形参的数量类型必须一致，否则编译会报错。对于函数指针也是如此。

## 函数声明与函数定义不一致
在Linux gcc下，如果程序中调用了没有声明的函数，编译器会默认将函数声明为返回值为int类型；如果在代码的后面出现了函数的定义但返回类型不匹配将报错。同时声明和定义的形参的类型以及返回值的类型必须一致，包括限定符。例如形参声明为`const char*`的定义不能为`char *`；在声明或定义前被调用的函数不能在之后被定义为static的（调用时编译器默认将其声明为 int，与后面的static int定义矛盾）。

## 函数调用实参与形参类型不匹配
AIX对函数调用时实参的类型要求不严格。例如，一个函数定义的参数时int型的，调用时可以用字符数组作为参数。在gcc中这是不允许的，编译的时候会报错。

##  函数返回值类型与定义不匹配
与实参和形参类似，AIX中对函数返回值的类型要求也不严格。例如一个函数定义为返回值为int的，可以返回NULL。在gcc中这是不允许的，函数的所有分支return的都需要是整数，否则编译会报错。

## 函数指针的用法
以下关于函数指针的写法AIX中合法的
```c
RESULT (* dealfunc)( CRecordSet, char * );
dealfunc = ( RESULT (*dealfunc)( CRecordSet, char * ) )dlsym( pDll, "GetTempRecord" );

在gcc中，这种写法会报错。需要修改为
dealfunc = ( RESULT (*)( CRecordSet, char *) )dlsym( pDll, "GetTempRecord" );
```
## 字符定义为 `''`
在AIX 下，空字符（''）是合法的，与 \0是一样的。在Linux中，空字符不是合法的字符，编译会报错。
在AIX与Linux下， ""是合法的，是指一个以NULL结尾的空字符串。而在AIX下，需要""的场合下可以用空字符（''）替代，语意相同。
示例代码：
```
char c=’’; (Linux error; AIX OK)
```
这个在Linux下编译报错；AIX正常，其相当于 char c=’\0’;
```
char *p=’’; (Linux error; AIX OK)
```
在Linux下编译报错；AIX正常，其相当于 char * p =””;

这个问题的解决方案是在编译时，根据编译器报错的问题，结合上下文判断其应该字符串还是字符；若应为字符串（例如，作为sprintf 格式为%s的位置的参数），则将其替换为””; 若为字符，替换为’\0’

## 关于va_arg() 的类型
在Linux下，实现可变参数的函数va_arg宏不能使用short int（编译器会提示）。原因是在C语言中，调用一个不带原型声明的函数时,调用者会对每个参数执行“默认实际参数提升(default argument promotions)”。同理，对可变长参数列表... 所对应的每一个实际参数，也将执行提升工作。提升的规则是，char与short类型都将被转换为int类型，float类型将被转换为double类型。
根据gcc调用函数规范，调用者准备堆栈。调用者根据上述原则准备堆栈，而va_arg宏实质上是根据参数取堆栈上一定大小的空间的值，如果使用va_arg的被调用者没有根据提升规则取值，其取到的值是错误的，对指针的话是指针的值即指针指向的地址是错误的，将会出先不可预知的错误。
这同时说明在未声明先调用函数，后面又出现定义时，参数不能是short int或char型的。

## 关于宏SO_REUSERPORT
Linux不支持SO_REUSEPORT，即使定义 #define SO_REUSEPORT 15，setsockopt也返回失败。
备注：新版本的Linux内核支持这个选项

## 支持的C语言标准
AIX与gcc支持的C语言标准有一定的差别，例如：是否支持在for循环里定义变量，for(int i=0; .... )
与C标准有关，gcc 默认不支持，可以编译时加参数-std=gnu99

小结：
以上问题都可以在编译阶段由编译器发现，相对比较好处理

# 不规范的用法

## 指针与整数混用
指针与整数相互赋值，在32位平台上编译器会给出警告；而在64位平台下 int 长度为4 ，指针类型（如void* ）长度为8，若不加区分的赋值会出现严重问题。
指针与整数的比较
指针类型的返回值的判断，如对共享内存shmat函数的返回值的判断，其成功返回地址，失败返回-1。如下两种对返回值进行判断的方法：
char * ptr  = shmat(k,NULL,flag);
if ( ( int ) ptr < 0 )  或
if(ptr <= 0)  都是不正确的
前者shmat正确返回的话，ptr的值最高位可能为1，int后为负数；后者因ptr无符号，这条语句总是为真。
正确的做法 if(ptr==(void*)-1)

## 调用未声明或定义的函数
在gcc中如果程序中调用了没有声明的函数，编译器会默认将函数声明为int返回值，如果函数没有声明但返回值不是int（例如是char * ）则有可能出现比较严重的问题。如果是64位平台，指针赋值给int会丢失数据，从而可能导致操作错误的内存地址，引发程序错误。

## 对不是malloc的内存进行free
 Linux gcc下，对不是动态申请（malloc）的内存进行释放（free）会引起程序coredump。AIX下不会。这种问题编译无法发现。尤其是对函数返回的指针，要清楚函数的实现，是否需要调用者释放内存。 对运行时的coredump进行分析解决。

## 函数return了局部数组变量
 AIX中，若函数返回值是函数中定义的局部数组变量不会报警告。而这在实际应用中可能出现问题。因为这样的函数返回值保留在栈上，如果调用这样的函数得到的返回值没有马上被使用就调用了另外的函数，堆栈会改变从而得到错误的值。
可以改用static，不过需要注意是否线程安全。
另外一种方案是在函数里动态申请内存作为返回值，缺点是调用者需要释放，若调用者不清楚函数的实现，没有进行free会造成内存泄露。
此外，还可以修改函数接口，调用者申请内存（或定义数组变量），传给函数，函数将返回结果写入参数。这样对代码改动比较大。

## 指针类型不匹配
指针类型不匹配会引发编译器的警告，实际中也可能因为传递了错误的指针（`*` 与 `**`）导致程序错误，因此最好消除指针类型不匹配的警告。根据编译器的提示分析代码，若确定无误，代码中强制类型转换消除警告。

# 运行阶段

## 对NULL指针解引用
Linux下对一个NULL的指针解引用取值会coredump。例如以下代码：
```c
char * ptr=NULL;
char c= *ptr;
```
在Linux下会coredump。而在AIX下不会，AIX下c的的值为0。
解决方案，新增代码，在对指针进行取值或其他操作时，先判断其是否为NULL，尤其是函数的参数，如果函数中不对指针参数的合法性进行判断检查，则调用者必须保证调用前指针参数的合法性。对现有的代码，进行梳理或者进行全面的测试，根据测试中发现的问题进行修改。

## 字符串操作函数
因Linux中对NULL指针取值会coredump，而gcc中字符串函数，如strcpy、strcat、strcmp、strlen 等为了效率其都没有检查参数的合法性，这就要求调用者保证函数参数的值都不能为NULL。
解决方案：
编写包装函数，接口与标准函数一致，在其中实现对输入参数的检查后调用库函数；然后方法一使用文本替换的方式将标准函数替换为包装函数。方法二定义宏，将宏定义为包装函数。
方法一的优点是代码清楚易读；缺点是所有的代码都有变动，增加了移植过程中文件的版本；开发人员在开发新的代码时需要牢记调用包装函数而不能调用标准函数。方法二要求项目中有公共的头文件
需要进行处理的函数：
strcpy strncpy strlen strcmp strncmp strcat strncat strstr strtok
memcpy memcmp memmove
关于sprintf的特殊说明：
sprintf(ret, “%s”, p); 编译器可能会优为 strcpy(ret,p);
sprintf(ret, “%10s”, p); 不会被优化

## char变量的符号
AIX下char默认是unsigned char；Linux下默认是signed char的。这点在移植过程中也需要注意。BEICS中有函数根据输入的字符串中是否有字符不在ASCII表范围内判断是否有汉字，进而调用编码转换函数。
解决方案显示的声明类型为signed char；或者使用gcc的参数 -fsigned-char指定。（参数 -fnosigned-char 指定char为unsigned char）。
